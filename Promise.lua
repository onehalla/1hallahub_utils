local a="Non-promise value passed into %s at index %s"local b="Please pass a list of promises to %s"local c="Please pass a handler function to %s!"local d={__mode="k"}local function e(f)if type(f)=="function"then return true end;if type(f)=="table"then local g=getmetatable(f)if g and type(rawget(g,"__call"))=="function"then return true end end;return false end;local function h(i,j)local k={}for l,m in ipairs(j)do k[m]=m end;return setmetatable(k,{__index=function(l,n)error(string.format("%s is not in %s!",n,i),2)end,__newindex=function()error(string.format("Creating new members in %s is not allowed!",i),2)end})end;local o;do o={Kind=h("Promise.Error.Kind",{"ExecutionError","AlreadyCancelled","NotResolvedInTime","TimedOut"})}o.__index=o;function o.new(p,q)p=p or{}return setmetatable({error=tostring(p.error)or"[This error has no error text.]",trace=p.trace,context=p.context,kind=p.kind,parent=q,createdTick=os.clock(),createdTrace=debug.traceback()},o)end;function o.is(r)if type(r)=="table"then local g=getmetatable(r)if type(g)=="table"then return rawget(r,"error")~=nil and type(rawget(g,"extend"))=="function"end end;return false end;function o.isKind(r,s)assert(s~=nil,"Argument #2 to Promise.Error.isKind must not be nil")return o.is(r)and r.kind==s end;function o:extend(p)p=p or{}p.kind=p.kind or self.kind;return o.new(p,self)end;function o:getErrorChain()local t={self}while t[#t].parent do table.insert(t,t[#t].parent)end;return t end;function o:__tostring()local u={string.format("-- Promise.Error(%s) --",self.kind or"?")}for l,v in ipairs(self:getErrorChain())do table.insert(u,table.concat({v.trace or v.error,v.context},"\n"))end;return table.concat(u,"\n")end end;local function w(...)return select("#",...),{...}end;local function x(y,...)return y,select("#",...),{...}end;local function z(A)assert(A~=nil,"traceback is nil")return function(B)if type(B)=="table"then return B end;return o.new({error=B,kind=o.Kind.ExecutionError,trace=debug.traceback(tostring(B),2),context="Promise created at:\n\n"..A})end end;local function C(A,D,...)return x(xpcall(D,z(A),...))end;local function E(A,D,F,G)return function(...)local H,I,J=C(A,D,...)if H then F(unpack(J,1,I))else G(J[1])end end end;local function K(L)return next(L)==nil end;local M={Error=o,Status=h("Promise.Status",{"Started","Resolved","Rejected","Cancelled"}),_getTime=os.clock,_timeEvent=game:GetService("RunService").Heartbeat,_unhandledRejectionCallbacks={}}M.prototype={}M.__index=M.prototype;function M._new(A,D,q)if q~=nil and not M.is(q)then error("Argument #2 to Promise.new must be a promise or nil",2)end;local self={_thread=nil,_source=A,_status=M.Status.Started,_values=nil,_valuesLength=-1,_unhandledRejection=true,_queuedResolve={},_queuedReject={},_queuedFinally={},_cancellationHook=nil,_parent=q,_consumers=setmetatable({},d)}if q and q._status==M.Status.Started then q._consumers[self]=true end;setmetatable(self,M)local function F(...)self:_resolve(...)end;local function G(...)self:_reject(...)end;local function N(O)if O then if self._status==M.Status.Cancelled then O()else self._cancellationHook=O end end;return self._status==M.Status.Cancelled end;self._thread=coroutine.create(function()local H,l,J=C(self._source,D,F,G,N)if not H then G(J[1])end end)task.spawn(self._thread)return self end;function M.new(P)return M._new(debug.traceback(nil,2),P)end;function M:__tostring()return string.format("Promise(%s)",self._status)end;function M.defer(P)local A=debug.traceback(nil,2)local Q;Q=M._new(A,function(F,G,N)local R;R=M._timeEvent:Connect(function()R:Disconnect()local H,l,J=C(A,P,F,G,N)if not H then G(J[1])end end)end)return Q end;M.async=M.defer;function M.resolve(...)local S,T=w(...)return M._new(debug.traceback(nil,2),function(F)F(unpack(T,1,S))end)end;function M.reject(...)local S,T=w(...)return M._new(debug.traceback(nil,2),function(l,G)G(unpack(T,1,S))end)end;function M._try(A,D,...)local U,T=w(...)return M._new(A,function(F)F(D(unpack(T,1,U)))end)end;function M.try(D,...)return M._try(debug.traceback(nil,2),D,...)end;function M._all(A,V,W)if type(V)~="table"then error(string.format(b,"Promise.all"),3)end;for X,Q in pairs(V)do if not M.is(Q)then error(string.format(a,"Promise.all",tostring(X)),3)end end;if#V==0 or W==0 then return M.resolve({})end;return M._new(A,function(F,G,N)local Y={}local Z={}local _=0;local a0=0;local a1=false;local function a2()for l,Q in ipairs(Z)do Q:cancel()end end;local function a3(X,...)if a1 then return end;_=_+1;if W==nil then Y[X]=...else Y[_]=...end;if _>=(W or#V)then a1=true;F(Y)a2()end end;N(a2)for X,Q in ipairs(V)do Z[X]=Q:andThen(function(...)a3(X,...)end,function(...)a0=a0+1;if W==nil or#V-a0<W then a2()a1=true;G(...)end end)end;if a1 then a2()end end)end;function M.all(V)return M._all(debug.traceback(nil,2),V)end;function M.fold(a4,a5,a6)assert(type(a4)=="table","Bad argument #1 to Promise.fold: must be a table")assert(e(a5),"Bad argument #2 to Promise.fold: must be a function")local a7=M.resolve(a6)return M.each(a4,function(a8,X)a7=a7:andThen(function(a9)return a5(a9,a8,X)end)end):andThen(function()return a7 end)end;function M.some(V,aa)assert(type(aa)=="number","Bad argument #2 to Promise.some: must be a number")return M._all(debug.traceback(nil,2),V,aa)end;function M.any(V)return M._all(debug.traceback(nil,2),V,1):andThen(function(T)return T[1]end)end;function M.allSettled(V)if type(V)~="table"then error(string.format(b,"Promise.allSettled"),2)end;for X,Q in pairs(V)do if not M.is(Q)then error(string.format(a,"Promise.allSettled",tostring(X)),2)end end;if#V==0 then return M.resolve({})end;return M._new(debug.traceback(nil,2),function(F,l,N)local ab={}local Z={}local ac=0;local function a3(X,...)ac=ac+1;ab[X]=...if ac>=#V then F(ab)end end;N(function()for l,Q in ipairs(Z)do Q:cancel()end end)for X,Q in ipairs(V)do Z[X]=Q:finally(function(...)a3(X,...)end)end end)end;function M.race(V)assert(type(V)=="table",string.format(b,"Promise.race"))for X,Q in pairs(V)do assert(M.is(Q),string.format(a,"Promise.race",tostring(X)))end;return M._new(debug.traceback(nil,2),function(F,G,N)local Z={}local ad=false;local function a2()for l,Q in ipairs(Z)do Q:cancel()end end;local function ae(D)return function(...)a2()ad=true;return D(...)end end;if N(ae(G))then return end;for X,Q in ipairs(V)do Z[X]=Q:andThen(ae(F),ae(G))end;if ad then a2()end end)end;function M.each(a4,af)assert(type(a4)=="table",string.format(b,"Promise.each"))assert(e(af),string.format(c,"Promise.each"))return M._new(debug.traceback(nil,2),function(F,G,N)local ag={}local ah={}local ai=false;local function a2()for l,aj in ipairs(ah)do aj:cancel()end end;N(function()ai=true;a2()end)local ak={}for al,f in ipairs(a4)do if M.is(f)then if f:getStatus()==M.Status.Cancelled then a2()return G(o.new({error="Promise is cancelled",kind=o.Kind.AlreadyCancelled,context=string.format("The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",al,f._source)}))elseif f:getStatus()==M.Status.Rejected then a2()return G(select(2,f:await()))end;local am=f:andThen(function(...)return...end)table.insert(ah,am)ak[al]=am else ak[al]=f end end;for al,f in ipairs(ak)do if M.is(f)then local y;y,f=f:await()if not y then a2()return G(f)end end;if ai then return end;local an=M.resolve(af(f,al))table.insert(ah,an)local y,J=an:await()if not y then a2()return G(J)end;ag[al]=J end;F(ag)end)end;function M.is(ao)if type(ao)~="table"then return false end;local ap=getmetatable(ao)if ap==M then return true elseif ap==nil then return e(ao.andThen)elseif type(ap)=="table"and type(rawget(ap,"__index"))=="table"and e(rawget(rawget(ap,"__index"),"andThen"))then return true end;return false end;function M.promisify(D)return function(...)return M._try(debug.traceback(nil,2),D,...)end end;do local aq;local R;function M.delay(ar)assert(type(ar)=="number","Bad argument #1 to Promise.delay, must be a number.")if not(ar>=1/60)or ar==math.huge then ar=1/60 end;return M._new(debug.traceback(nil,2),function(F,l,N)local as=M._getTime()local at=as+ar;local au={resolve=F,startTime=as,endTime=at}if R==nil then aq=au;R=M._timeEvent:Connect(function()local av=M._getTime()while aq~=nil and aq.endTime<av do local aw=aq;aq=aw.next;if aq==nil then R:Disconnect()R=nil else aq.previous=nil end;aw.resolve(M._getTime()-aw.startTime)end end)else if aq.endTime<at then local aw=aq;local next=aw.next;while next~=nil and next.endTime<at do aw=next;next=aw.next end;aw.next=au;au.previous=aw;if next~=nil then au.next=next;next.previous=au end else au.next=aq;aq.previous=au;aq=au end end;N(function()local next=au.next;if aq==au then if next==nil then R:Disconnect()R=nil else next.previous=nil end;aq=next else local ax=au.previous;ax.next=next;if next~=nil then next.previous=ax end end end)end)end end;function M.prototype:timeout(ar,ay)local A=debug.traceback(nil,2)return M.race({M.delay(ar):andThen(function()return M.reject(ay==nil and o.new({kind=o.Kind.TimedOut,error="Timed out",context=string.format("Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",ar,A)})or ay)end),self})end;function M.prototype:getStatus()return self._status end;function M.prototype:_andThen(A,az,aA)self._unhandledRejection=false;if self._status==M.Status.Cancelled then local Q=M.new(function()end)Q:cancel()return Q end;return M._new(A,function(F,G,N)local aB=F;if az then aB=E(A,az,F,G)end;local aC=G;if aA then aC=E(A,aA,F,G)end;if self._status==M.Status.Started then table.insert(self._queuedResolve,aB)table.insert(self._queuedReject,aC)N(function()if self._status==M.Status.Started then table.remove(self._queuedResolve,table.find(self._queuedResolve,aB))table.remove(self._queuedReject,table.find(self._queuedReject,aC))end end)elseif self._status==M.Status.Resolved then aB(unpack(self._values,1,self._valuesLength))elseif self._status==M.Status.Rejected then aC(unpack(self._values,1,self._valuesLength))end end,self)end;function M.prototype:andThen(az,aA)assert(az==nil or e(az),string.format(c,"Promise:andThen"))assert(aA==nil or e(aA),string.format(c,"Promise:andThen"))return self:_andThen(debug.traceback(nil,2),az,aA)end;function M.prototype:catch(aA)assert(aA==nil or e(aA),string.format(c,"Promise:catch"))return self:_andThen(debug.traceback(nil,2),nil,aA)end;function M.prototype:tap(aD)assert(e(aD),string.format(c,"Promise:tap"))return self:_andThen(debug.traceback(nil,2),function(...)local aE=aD(...)if M.is(aE)then local S,T=w(...)return aE:andThen(function()return unpack(T,1,S)end)end;return...end)end;function M.prototype:andThenCall(D,...)assert(e(D),string.format(c,"Promise:andThenCall"))local S,T=w(...)return self:_andThen(debug.traceback(nil,2),function()return D(unpack(T,1,S))end)end;function M.prototype:andThenReturn(...)local S,T=w(...)return self:_andThen(debug.traceback(nil,2),function()return unpack(T,1,S)end)end;function M.prototype:cancel()if self._status~=M.Status.Started then return end;self._status=M.Status.Cancelled;if self._cancellationHook then self._cancellationHook()end;coroutine.close(self._thread)if self._parent then self._parent:_consumerCancelled(self)end;for aF in pairs(self._consumers)do aF:cancel()end;self:_finalize()end;function M.prototype:_consumerCancelled(aG)if self._status~=M.Status.Started then return end;self._consumers[aG]=nil;if next(self._consumers)==nil then self:cancel()end end;function M.prototype:_finally(A,aH)self._unhandledRejection=false;local Q=M._new(A,function(F,G,N)local aI;N(function()self:_consumerCancelled(self)if aI then aI:cancel()end end)local aJ=F;if aH then aJ=function(...)local aE=aH(...)if M.is(aE)then aI=aE;aE:finally(function(aK)if aK~=M.Status.Rejected then F(self)end end):catch(function(...)G(...)end)else F(self)end end end;if self._status==M.Status.Started then table.insert(self._queuedFinally,aJ)else aJ(self._status)end end)return Q end;function M.prototype:finally(aH)assert(aH==nil or e(aH),string.format(c,"Promise:finally"))return self:_finally(debug.traceback(nil,2),aH)end;function M.prototype:finallyCall(D,...)assert(e(D),string.format(c,"Promise:finallyCall"))local S,T=w(...)return self:_finally(debug.traceback(nil,2),function()return D(unpack(T,1,S))end)end;function M.prototype:finallyReturn(...)local S,T=w(...)return self:_finally(debug.traceback(nil,2),function()return unpack(T,1,S)end)end;function M.prototype:awaitStatus()self._unhandledRejection=false;if self._status==M.Status.Started then local aL=coroutine.running()self:finally(function()task.spawn(aL)end):catch(function()end)coroutine.yield()end;if self._status==M.Status.Resolved then return self._status,unpack(self._values,1,self._valuesLength)elseif self._status==M.Status.Rejected then return self._status,unpack(self._values,1,self._valuesLength)end;return self._status end;local function aM(aK,...)return aK==M.Status.Resolved,...end;function M.prototype:await()return aM(self:awaitStatus())end;local function aN(aK,...)if aK~=M.Status.Resolved then error(...==nil and"Expected Promise rejected with no value."or...,3)end;return...end;function M.prototype:expect()return aN(self:awaitStatus())end;M.prototype.awaitValue=M.prototype.expect;function M.prototype:_unwrap()if self._status==M.Status.Started then error("Promise has not resolved or rejected.",2)end;local y=self._status==M.Status.Resolved;return y,unpack(self._values,1,self._valuesLength)end;function M.prototype:_resolve(...)if self._status~=M.Status.Started then if M.is(...)then...:_consumerCancelled(self)end;return end;if M.is(...)then if select("#",...)>1 then local aO=string.format("When returning a Promise from andThen, extra arguments are ".."discarded! See:\n\n%s",self._source)warn(aO)end;local aP=...local Q=aP:andThen(function(...)self:_resolve(...)end,function(...)local aQ=aP._values[1]if aP._error then aQ=o.new({error=aP._error,kind=o.Kind.ExecutionError,context="[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]"})end;if o.isKind(aQ,o.Kind.ExecutionError)then return self:_reject(aQ:extend({error="This Promise was chained to a Promise that errored.",trace="",context=string.format("The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",self._source)}))end;self:_reject(...)end)if Q._status==M.Status.Cancelled then self:cancel()elseif Q._status==M.Status.Started then self._parent=Q;Q._consumers[self]=true end;return end;self._status=M.Status.Resolved;self._valuesLength,self._values=w(...)for l,D in ipairs(self._queuedResolve)do coroutine.wrap(D)(...)end;self:_finalize()end;function M.prototype:_reject(...)if self._status~=M.Status.Started then return end;self._status=M.Status.Rejected;self._valuesLength,self._values=w(...)if not K(self._queuedReject)then for l,D in ipairs(self._queuedReject)do coroutine.wrap(D)(...)end else local B=tostring(...)coroutine.wrap(function()M._timeEvent:Wait()if not self._unhandledRejection then return end;local aO=string.format("Unhandled Promise rejection:\n\n%s\n\n%s",B,self._source)for l,D in ipairs(M._unhandledRejectionCallbacks)do task.spawn(D,self,unpack(self._values,1,self._valuesLength))end;if M.TEST then return end;warn(aO)end)()end;self:_finalize()end;function M.prototype:_finalize()for l,D in ipairs(self._queuedFinally)do coroutine.wrap(D)(self._status)end;self._queuedFinally=nil;self._queuedReject=nil;self._queuedResolve=nil;if not M.TEST then self._parent=nil;self._consumers=nil end;task.defer(coroutine.close,self._thread)end;function M.prototype:now(ay)local A=debug.traceback(nil,2)if self._status==M.Status.Resolved then return self:_andThen(A,function(...)return...end)else return M.reject(ay==nil and o.new({kind=o.Kind.NotResolvedInTime,error="This Promise was not resolved in time for :now()",context=":now() was called at:\n\n"..A})or ay)end end;function M.retry(D,aR,...)assert(e(D),"Parameter #1 to Promise.retry must be a function")assert(type(aR)=="number","Parameter #2 to Promise.retry must be a number")local aS,S={...},select("#",...)return M.resolve(D(...)):catch(function(...)if aR>0 then return M.retry(D,aR-1,unpack(aS,1,S))else return M.reject(...)end end)end;function M.retryWithDelay(D,aR,ar,...)assert(e(D),"Parameter #1 to Promise.retry must be a function")assert(type(aR)=="number","Parameter #2 (times) to Promise.retry must be a number")assert(type(ar)=="number","Parameter #3 (seconds) to Promise.retry must be a number")local aS,S={...},select("#",...)return M.resolve(D(...)):catch(function(...)if aR>0 then M.delay(ar):await()return M.retryWithDelay(D,aR-1,ar,unpack(aS,1,S))else return M.reject(...)end end)end;function M.fromEvent(aT,af)af=af or function()return true end;return M._new(debug.traceback(nil,2),function(F,l,N)local R;local aU=false;local function aV()R:Disconnect()R=nil end;R=aT:Connect(function(...)local aW=af(...)if aW==true then F(...)if R then aV()else aU=true end elseif type(aW)~="boolean"then error("Promise.fromEvent predicate should always return a boolean")end end)if aU and R then return aV()end;N(aV)end)end;function M.onUnhandledRejection(D)table.insert(M._unhandledRejectionCallbacks,D)return function()local al=table.find(M._unhandledRejectionCallbacks,D)if al then table.remove(M._unhandledRejectionCallbacks,al)end end end;return M
